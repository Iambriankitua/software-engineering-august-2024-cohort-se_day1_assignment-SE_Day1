# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

Software engineering systematically applies engineering principles, methods, and tools to develop and maintain high-quality software systems. It involves software product design, development, testing, deployment, and maintenance.
Importance of software engineering in the technology industry: Software engineering plays a crucial role in the technology industry by enabling the creation of software applications and systems that power various aspects of modern life, including communication, commerce, entertainment, and healthcare.

Identify and describe at least three key milestones in the evolution of software engineering.

SE Era I: Mastering the Machine (1956–1967). The term software engineering had not yet been coined. Code development was strongly influenced by outside forces. The main purpose of any piece of software was to optimize exploitation of the limited hardware resources. The first compilers were defined; operating systems were noninteractive. These primitive environments continued evolving up to the definition of the first low-level Computer Aided Software Engineering tools (CASE tools) facilitating interactive editing, compiling, and debugging. The lack of software development methods led to high risk and the origin of a new stage is easily noticeable.

SE Era II: Mastering the Process (1968–1982). The first softwarecrisisinthisstageledtothebirthofsoftware engineering. The aim was to reduce risk during development and improve quality and productivity. Software development methodologies appeared to define and monitor software building. An important contribution of this stage was the formal modeling approach that enables implementation automation. But for industry, this formal approach was unfeasible due to a lack of tools and training. Furthermore, formalmethodsbecomeunmanageableforlargesystem development. In conclusion, in this stage, the need to focus on predesign phases and the use of more or less formal models for software specification began to appear. A number of structured methods, such as Software Requirement Engineering Methodology (SREM) and the Structured Analysis and Design Technique (SADT) were developed allowing the development of specification documents for business management software. 

SE Era III: Mastering the Complexity (1983–1992). The up to then dominion of hardware over software ended. Personal computers arrived and opened the fields of computer applications. The software development process would now comprehensively address analysis and design from the specification. Graphical user interface and visual programming brought software closer to customers. The use of structured family and data modeling methodologies was extended. Several CASE tools facilitated software development. However, data modeling (database) and function modeling (structured methods) still followed separate paths. These two modeling paths converged in object-oriented (OO) methods like early on in structured methodologies, they were first introduced in coding and design, and finally in specification and analysis. This approach enabled efficient reuse of object-oriented software and thus improves building software productivity.

List and briefly explain the phases of the Software Development Life Cycle.

There are 7 software development life cycle phases, and they are to be approached sequentially, although in some cases, two might run concurrently (just as development and testing).
1. Planning- In this phase, the project leads to defining the project’s purpose and the desired result. If the team is developing for a customer instead of a market, the project manager meets with them to discuss the product, its purpose, and the results they want to achieve. The team gathers as much information about the product from the customer.
2. Requirements- this second phase of the software development life cycle is often done concurrently with the first. Here, the project lead analyzes the product or client’s goals and decides on the features to aim for as a final goal. Defining and establishing requirements determines what the application will do once launched, the necessary components, and the resources needed to launch it.
3. Design and Prototype- Once phases 1 and 2 are understood and established, developers can start designing the software. The design phase defines how a software application will work. During this phase, teams decide on the programming language, screen layouts, and relevant documentation they will use. Some of the fundamental aspects developers cover during this phase are: Architecture, User Interface (UI), Security and Programming.
Prototyping is also part of this phase. A prototype is a basic idea of how the application looks and works. Prototypes allow customers to get a sneak peek of how their application will look; they might even discover that their original idea is not good enough and change it during this phase.
4. Software Development- During this phase, developers start programming. If they work on a small project, one developer takes over the coding tasks, while on large projects, the codebase might be worked on by several developers. Before starting to code, teams must have clear predefined guidelines to ensure the code’s quality. In this phase, developers start building the entire system and shaping the project. Depending on each team’s model, the phase may be conducted in sprints (Agile) or a single block (Waterfall). Teams spend most of their time during this phase ensuring that the application will work efficiently. 
5. Testing- Often, testing happens in parallel with development, as developers write and test the code they’ve produced before moving on to the next coding task. During this phase, different types of testing occur, such as code quality, unit testing, integration testing, performance testing, and security testing.
6. Deployment- The deployment process starts once the testing phase is over and there are no bugs or errors in the development backlog. The team ensures that the software is up-to-date and secure enough for users and pushes it from the development environment to a live environment–usually an app store. During this phase, the tech support team looks for user feedback and ensures it reaches the dev team.
7. Maintenance- At this point in the SDLC cycle, the application is successfully launched and being used. Yet this last phase is still important because bugs or errors missed during testing are bound to appear. Simultaneously, by studying user behavior and feedback, the team can start to think about and plan for upgrades. 

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
1. Roles: Waterfall strictly assigns roles to project team members, with specific duties and responsibilities defined for each team member. In contrast, the agile model empowers team members to collaborate on different aspects of the project over time, leading to a more self-organizing team structure.
2. Planning: In waterfall, planning is a linear process done at the beginning of the project, with all requirements and objectives laid out in detail upfront. In contrast, agile planning is a continuous process throughout the project's life cycle, with adjustments made as new information or requirements emerge.
3. Scope: The waterfall methodology generally discourages changes to the project's scope, even with change requests used correctly. This is because the methodology requires an extensive amount of time spent in the beginning trying to get the plan right, which can make changes more costly after the project has begun. On the other hand, agile is more adaptable to changes in scope, with the development team able to adjust quickly as requirements change.
4. Time frames: The waterfall method is designed for long-term projects with predetermined timelines. The project is completed linearly, with each phase dependent on the previous one. Agile, however, uses short iterations to deliver value rapidly, allowing teams to adjust plans over time and achieve shorter time frames.
5. Speed: Waterfall projects tend to take longer because all requirements must be agreed upon before development can begin. Agile projects, on the other hand, are usually delivered more rapidly than waterfall projects due to the iterative development cycles used in agile.
6. Delivery: Agile allows for quick delivery of projects with shorter lifecycles, as each iteration delivers a workable product. Waterfall requires the completion of all tasks before any work can be released.
7. Flexibility: Agile encourages teams to respond quickly and adaptively to changes during the development process. Waterfall is less flexible and resistant to change once the project's scope has been defined.
8. Testing: Testing is essential to the agile and waterfall methodologies, but the approaches differ significantly. Agile emphasizes incremental testing to identify and resolve issues throughout the development process. In waterfall, testing is usually done at specific milestones, often towards the end of the project.

The waterfall model fits projects with the following characteristics:

    Simple scope and requirement gathering
    Clear and linear sequence of tasks
    Predictable deliverables based on set deadlines
    Structured processes
    Rigid quality control measures
    Long-term commitment from all parties involved

Agile project management can be an excellent fit for many teams and projects, especially those that meet the criteria below:

    Complex deliverables
    Frequent iterations and refinements
    Rapid delivery times
    Emergent requirements
    Collaborative environments
    Multiple stakeholders


Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

Software Developer- The developer is responsible for writing the code and developing the entire software product. Aside from coding, a software developer is responsible for sending updates to the project manager and working closely with other team members, including the designer and QA engineer. 
       Responsibilities:
1. Developing applications, programs and systems using programming languages and frameworks.
2. Maintaining and updating software to keep it functional.
3. Collaborating with other team members to ensure best practices when developing software.
4. Report to the project manager about the progress of the software development.  

Quality Assurance Engineer- The QA or quality assurance engineer creates tests that identify issues with software before it is deployed. QA engineers monitor every phase of the software development process, including development, testing, debugging and delivery. They ensure that quality is maintained at every stage of the development process and that the final product meets the requirements.       
       Responsibilities:
1. Collaborate with stakeholders to understand and clarify software requirements.
2. Create development standards and procedures for the programmers to follow.
3. Confirm that the software meets the requirements before deployment.
4. Analyse the product to identify bugs and suggest changes to make them more efficient.
5. Develop and execute automation scripts using open-source tools.

Project Manager- In software development, the roles of the project manager may include helping the team to design, execute, monitor and finish their work so that the clients will receive higher-quality software products.     
       Responsibilities:
1. Discuss the project and its requirements with clients and software developers.
2. Assemble and lead the software development team.
3. Create the blueprint for the project, including the scope, allocating resources, setting deadlines and laying out communication strategies.
4. Supervising each stage of the software development project.
5. Set the budget and ensure the project adheres to it as closely as possible.
6. Tracking and communicating information regarding the project milestones, deliverables and change requests.
7. Deliver the completed software to the client and regularly check its performance. 


Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

Integrated Development Environments (IDEs) are essential software tools that provide a comprehensive set of tools for developing applications efficiently. IDEs typically include a code editor, debugger, build automation tools, and integrated version control systems, all in one place. Using an IDE can significantly increase productivity, improve code quality, and streamline the development process.
     Examples include: Popular IDEs include Visual Studio Code, IntelliJ IDEA, Eclipse, Xcode, and Android Studio, each with its own strengths and specialties

Version control lets you track file changes and access specific versions when needed. It helps developers collaborate and is essential to any successful software project. From simple file backups in the 1970s to centralized CVS and distributed Git, version control systems have evolved dramatically. This evolution has improved coding efficiency and collaboration, shaping software development. Benefits of Using Version Control: enhance collaboration, track changes, experimentation and rollback.
     Examples include: Popular Version Control Systems incude; Git, Subversion (SVN) and Mercurial.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

1. Lack of Workflow Visibility
How to Combat Lack of Visibility in Development Teams:
    Invest in tools that empower your teams to make data-driven decisions: .i.e. Project management tools, Engineering analytics tools and Observability & monitoring tools.
2. Broken SDLC Processes
How to Improve Your SDLC Process: Workflow Management, Clear scope of work, Documentation, Scrum Best Practices, Integration, Tracking engineering metrics, Collaborative Learning, Breaking Down the Tasks and Data-Driven Success

    
Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

1. Unit testing-is a method of testing individual units or components of a software application. It is typically done by developers and is used to ensure that the individual units of the software are working as intended. Unit tests are usually automated and are designed to test specific parts of the code, such as a particular function or method. Unit testing is done at the lowest level of the software development process , where individual units of code are tested in isolation. Example: In a program we are checking if the loop, method, or function is working fine. 
2. Integration Testing- It is used to identify and resolve any issues that may arise when different units of the software are combined.
3. System Testing is a type of software testing that is performed on a completely integrated system to evaluate the compliance of the system with the corresponding requirements. In system testing, integration testing passed components are taken as input. The goal of integration testing is to detect any irregularity between the units that are integrated.
4. Acceptance Testing- Acceptance testing is the process of testing an application to ensure that it meets the requirements and expectations of its end users. In Salesforce, acceptance testing typically involves testing the application’s functionality from the perspective of end-users, including testing the user interface, user experience, and overall functionality.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the process of iterating a generative AI prompt to improve its accuracy and effectiveness. Learn all about prompt engineering and how it works.
                                        Importance in interacting with AI models.
Prompt engineering makes it easy for users to obtain relevant results in the first prompt. It helps mitigate bias that may be present from existing human bias in the large language models' training data. Further, it enhances the user-AI interaction so the AI understands the user's intention even with minimal input.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

A simple example: If you ask, 'Tell me about cats,' the AI might give a general answer. 
But if you ask, 'Tell me about the history of domestic cats,' you'll get a more focused response."
     Why the improved prompt is more effective: because its more effective, clear, specific and concise.
